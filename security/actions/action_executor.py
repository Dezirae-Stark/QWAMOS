#!/usr/bin/env python3
"""
QWAMOS Action Executor

Executes security response actions generated by AI Response Coordinator.
Actions include: firewall rules, process termination, network isolation,
VM snapshots, file quarantine, and automated patching.

All actions are logged and require appropriate permissions.
"""

import os
import subprocess
import time
import json
import logging
import shutil
from typing import Dict, List
from pathlib import Path
import asyncio

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('ActionExecutor')


class ActionExecutor:
    """
    Execute security response actions with permission control
    """

    def __init__(self, config_path='/opt/qwamos/security/config/action_executor_config.json'):
        """
        Initialize Action Executor

        Args:
            config_path: Path to configuration file
        """
        self.config_path = config_path
        self.config = self._load_config()

        # Action history
        self.action_history = []

        # Quarantine directory
        self.quarantine_dir = Path('/opt/qwamos/security/quarantine')
        self.quarantine_dir.mkdir(parents=True, exist_ok=True)

        # Statistics
        self.actions_executed = 0
        self.actions_failed = 0

        logger.info("Action Executor initialized")

    def _load_config(self) -> Dict:
        """Load configuration"""
        default_config = {
            'dry_run': False,  # If True, log actions but don't execute
            'log_actions': True,
            'backup_before_action': True,
            'max_concurrent_actions': 10,
            'action_timeout': 300,  # 5 minutes
            'allowed_actions': [
                'firewall', 'kill_process', 'network_isolation',
                'vm_snapshot', 'quarantine_file', 'patch'
            ]
        }

        try:
            with open(self.config_path, 'r') as f:
                config = json.load(f)
                return {**default_config, **config}
        except:
            return default_config

    async def execute(self, action: Dict) -> Dict:
        """
        Execute a single action

        Args:
            action: Action dictionary with 'type' and parameters

        Returns:
            dict: Execution result
        """
        action_type = action.get('type')

        if action_type not in self.config['allowed_actions']:
            logger.error(f"Action type not allowed: {action_type}")
            return {'success': False, 'error': 'Action type not allowed'}

        logger.info(f"Executing action: {action_type}")

        # Log action
        if self.config['log_actions']:
            self._log_action(action)

        # Dry run mode
        if self.config['dry_run']:
            logger.info(f"DRY RUN: Would execute {action_type}")
            return {'success': True, 'dry_run': True}

        # Route to appropriate handler
        try:
            if action_type == 'firewall':
                result = await self._execute_firewall(action)
            elif action_type == 'kill_process':
                result = await self._execute_kill_process(action)
            elif action_type == 'network_isolation':
                result = await self._execute_network_isolation(action)
            elif action_type == 'vm_snapshot':
                result = await self._execute_vm_snapshot(action)
            elif action_type == 'quarantine_file':
                result = await self._execute_quarantine_file(action)
            elif action_type == 'patch':
                result = await self._execute_patch(action)
            else:
                result = {'success': False, 'error': f'Unknown action type: {action_type}'}

            if result.get('success'):
                self.actions_executed += 1
            else:
                self.actions_failed += 1

            return result

        except Exception as e:
            logger.error(f"Action execution error: {e}")
            self.actions_failed += 1
            return {'success': False, 'error': str(e)}

    async def _execute_firewall(self, action: Dict) -> Dict:
        """Execute firewall rule addition"""
        rule = action.get('command') or action.get('rule')

        if not rule:
            return {'success': False, 'error': 'No firewall rule specified'}

        logger.info(f"Adding firewall rule: {rule}")

        try:
            # Use nftables (modern Linux firewall)
            # Parse rule and add to appropriate chain

            # Example: block IP address
            if 'block' in rule.lower() or 'drop' in rule.lower():
                # Extract IP if present
                import re
                ip_match = re.search(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', rule)
                if ip_match:
                    ip = ip_match.group(0)

                    cmd = [
                        'nft', 'add', 'rule', 'inet', 'filter', 'input',
                        'ip', 'saddr', ip, 'drop'
                    ]

                    result = subprocess.run(
                        cmd,
                        capture_output=True,
                        text=True,
                        timeout=30
                    )

                    if result.returncode == 0:
                        logger.info(f"Blocked IP: {ip}")
                        return {
                            'success': True,
                            'action': 'firewall',
                            'details': f'Blocked {ip}'
                        }
                    else:
                        logger.error(f"Firewall rule failed: {result.stderr}")
                        return {
                            'success': False,
                            'error': result.stderr
                        }

            # Generic rule execution
            result = subprocess.run(
                ['nft'] + rule.split(),
                capture_output=True,
                text=True,
                timeout=30
            )

            return {
                'success': result.returncode == 0,
                'action': 'firewall',
                'output': result.stdout,
                'error': result.stderr if result.returncode != 0 else None
            }

        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Firewall command timed out'}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    async def _execute_kill_process(self, action: Dict) -> Dict:
        """Execute process termination"""
        pid = action.get('pid')

        if not pid:
            return {'success': False, 'error': 'No PID specified'}

        logger.warning(f"Killing process: {pid}")

        try:
            # Try graceful termination first (SIGTERM)
            result = subprocess.run(
                ['kill', str(pid)],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                logger.info(f"Process {pid} terminated gracefully")
                return {
                    'success': True,
                    'action': 'kill_process',
                    'pid': pid,
                    'method': 'SIGTERM'
                }

            # If graceful failed, force kill (SIGKILL)
            result = subprocess.run(
                ['kill', '-9', str(pid)],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                logger.info(f"Process {pid} force killed")
                return {
                    'success': True,
                    'action': 'kill_process',
                    'pid': pid,
                    'method': 'SIGKILL'
                }
            else:
                return {
                    'success': False,
                    'error': f'Failed to kill process {pid}: {result.stderr}'
                }

        except Exception as e:
            return {'success': False, 'error': str(e)}

    async def _execute_network_isolation(self, action: Dict) -> Dict:
        """Execute network isolation (VM or interface shutdown)"""
        command = action.get('command')
        vm = action.get('vm')

        logger.warning(f"Executing network isolation: {command or vm}")

        try:
            if vm:
                # Isolate specific VM by shutting down its network interface
                result = subprocess.run(
                    ['virsh', 'domif-setlink', vm, 'vnet0', 'down'],
                    capture_output=True,
                    text=True,
                    timeout=30
                )

                if result.returncode == 0:
                    logger.info(f"VM {vm} network isolated")
                    return {
                        'success': True,
                        'action': 'network_isolation',
                        'vm': vm
                    }
                else:
                    return {
                        'success': False,
                        'error': f'Failed to isolate VM {vm}: {result.stderr}'
                    }

            elif command:
                # Execute custom isolation command
                result = subprocess.run(
                    command.split(),
                    capture_output=True,
                    text=True,
                    timeout=30
                )

                return {
                    'success': result.returncode == 0,
                    'action': 'network_isolation',
                    'output': result.stdout,
                    'error': result.stderr if result.returncode != 0 else None
                }

            else:
                return {'success': False, 'error': 'No isolation target specified'}

        except Exception as e:
            return {'success': False, 'error': str(e)}

    async def _execute_vm_snapshot(self, action: Dict) -> Dict:
        """Execute VM snapshot"""
        vm = action.get('vm')

        if not vm:
            return {'success': False, 'error': 'No VM specified'}

        snapshot_name = f"qwamos_threat_{int(time.time())}"
        logger.info(f"Creating VM snapshot: {vm} -> {snapshot_name}")

        try:
            # Create QEMU snapshot
            result = subprocess.run(
                ['virsh', 'snapshot-create-as', vm, snapshot_name,
                 '--description', 'QWAMOS threat detection snapshot'],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0:
                logger.info(f"VM snapshot created: {snapshot_name}")
                return {
                    'success': True,
                    'action': 'vm_snapshot',
                    'vm': vm,
                    'snapshot': snapshot_name
                }
            else:
                return {
                    'success': False,
                    'error': f'Snapshot failed: {result.stderr}'
                }

        except Exception as e:
            return {'success': False, 'error': str(e)}

    async def _execute_quarantine_file(self, action: Dict) -> Dict:
        """Execute file quarantine (move to safe location)"""
        file_path = action.get('file')

        if not file_path:
            return {'success': False, 'error': 'No file specified'}

        logger.warning(f"Quarantining file: {file_path}")

        try:
            source = Path(file_path)

            if not source.exists():
                return {'success': False, 'error': f'File not found: {file_path}'}

            # Create quarantine subdirectory with timestamp
            quarantine_subdir = self.quarantine_dir / time.strftime('%Y%m%d')
            quarantine_subdir.mkdir(parents=True, exist_ok=True)

            # Generate safe filename
            safe_filename = f"{int(time.time())}_{source.name}"
            destination = quarantine_subdir / safe_filename

            # Backup original if configured
            if self.config['backup_before_action']:
                backup_path = destination.with_suffix(destination.suffix + '.backup')
                shutil.copy2(source, backup_path)

            # Move to quarantine
            shutil.move(str(source), str(destination))

            # Change permissions to read-only
            os.chmod(destination, 0o400)

            logger.info(f"File quarantined: {file_path} -> {destination}")

            # Save metadata
            metadata = {
                'original_path': str(file_path),
                'quarantine_path': str(destination),
                'timestamp': time.time(),
                'threat_type': action.get('threat_type', 'unknown'),
                'size': destination.stat().st_size
            }

            metadata_path = destination.with_suffix('.json')
            with open(metadata_path, 'w') as f:
                json.dump(metadata, f, indent=2)

            return {
                'success': True,
                'action': 'quarantine_file',
                'original': str(file_path),
                'quarantine': str(destination)
            }

        except Exception as e:
            logger.error(f"Quarantine failed: {e}")
            return {'success': False, 'error': str(e)}

    async def _execute_patch(self, action: Dict) -> Dict:
        """Execute automated patching"""
        patch_type = action.get('patch_type', 'system')
        package = action.get('package')

        logger.info(f"Executing patch: {patch_type} - {package}")

        try:
            if patch_type == 'system':
                # System package update
                if package:
                    # Update specific package
                    result = subprocess.run(
                        ['apt-get', 'install', '--only-upgrade', '-y', package],
                        capture_output=True,
                        text=True,
                        timeout=300
                    )
                else:
                    # Update all packages
                    result = subprocess.run(
                        ['apt-get', 'upgrade', '-y'],
                        capture_output=True,
                        text=True,
                        timeout=600
                    )

                return {
                    'success': result.returncode == 0,
                    'action': 'patch',
                    'patch_type': 'system',
                    'package': package,
                    'output': result.stdout[:500],  # Truncate output
                    'error': result.stderr if result.returncode != 0 else None
                }

            elif patch_type == 'kernel':
                # Kernel patch (requires reboot)
                logger.warning("Kernel patch requested - requires reboot")
                return {
                    'success': False,
                    'error': 'Kernel patching requires manual intervention and reboot'
                }

            else:
                return {'success': False, 'error': f'Unknown patch type: {patch_type}'}

        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _log_action(self, action: Dict):
        """Log action to history"""
        log_entry = {
            'timestamp': time.time(),
            'action': action,
            'executed_by': 'ActionExecutor'
        }

        self.action_history.append(log_entry)

        # Write to file
        log_file = Path('/var/log/qwamos/action_executor.log')
        log_file.parent.mkdir(parents=True, exist_ok=True)

        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')

    def restore_from_quarantine(self, quarantine_path: str, original_path: str = None) -> Dict:
        """
        Restore a file from quarantine

        Args:
            quarantine_path: Path to quarantined file
            original_path: Original path to restore to (from metadata if None)

        Returns:
            dict: Restoration result
        """
        try:
            source = Path(quarantine_path)

            if not source.exists():
                return {'success': False, 'error': 'Quarantined file not found'}

            # Load metadata
            metadata_path = source.with_suffix('.json')
            if metadata_path.exists() and not original_path:
                with open(metadata_path, 'r') as f:
                    metadata = json.load(f)
                    original_path = metadata.get('original_path')

            if not original_path:
                return {'success': False, 'error': 'Original path not specified'}

            destination = Path(original_path)

            # Restore file
            shutil.move(str(source), str(destination))

            # Restore original permissions
            os.chmod(destination, 0o644)

            logger.info(f"File restored: {quarantine_path} -> {original_path}")

            return {
                'success': True,
                'restored_to': str(original_path)
            }

        except Exception as e:
            return {'success': False, 'error': str(e)}

    def get_statistics(self) -> Dict:
        """Get executor statistics"""
        return {
            'actions_executed': self.actions_executed,
            'actions_failed': self.actions_failed,
            'success_rate': self.actions_executed / max(self.actions_executed + self.actions_failed, 1),
            'quarantined_files': len(list(self.quarantine_dir.rglob('*.*')))
        }

    def list_quarantined_files(self) -> List[Dict]:
        """List all quarantined files"""
        files = []

        for metadata_file in self.quarantine_dir.rglob('*.json'):
            try:
                with open(metadata_file, 'r') as f:
                    metadata = json.load(f)
                    files.append(metadata)
            except:
                pass

        return files


# CLI Interface
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='QWAMOS Action Executor')
    parser.add_argument('--test', action='store_true', help='Run test actions')
    args = parser.parse_args()

    if args.test:
        async def test_executor():
            executor = ActionExecutor()

            # Test actions
            test_actions = [
                {'type': 'vm_snapshot', 'vm': 'workstation-1'},
                {'type': 'quarantine_file', 'file': '/tmp/suspicious_file.txt'},
            ]

            for action in test_actions:
                result = await executor.execute(action)
                logger.info(f"Result: {json.dumps(result, indent=2)}")

            stats = executor.get_statistics()
            logger.info(f"Statistics: {json.dumps(stats, indent=2)}")

        asyncio.run(test_executor())
